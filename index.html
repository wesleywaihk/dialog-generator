<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON å°è©± TTS é–±è®€å™¨</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .controls, .dialogue-controls { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .dialogue-line { margin-bottom: 10px; padding: 10px; border-bottom: 1px dashed #eee; cursor: pointer; }
        .dialogue-line:hover { background-color: #f0f0f0; }
        .speaker { font-weight: bold; margin-right: 10px; }
        .current-speaking { background-color: #e6f7ff; border-left: 5px solid #007bff; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 300px; }
        button { padding: 10px 15px; margin-right: 10px; cursor: pointer; }
        #log { margin-top: 20px; padding: 10px; background-color: #f9f9f9; border: 1px solid #ddd; max-height: 150px; overflow-y: auto; }
    </style>
</head>
<body>

    <h1>ğŸ—£ï¸ JSON å°è©± TTS é–±è®€å™¨</h1>

    <div class="controls">
        <label for="fileInput">é¸æ“‡ JSON å°è©±æª”æ¡ˆ:</label>
        <input type="file" id="fileInput" accept="application/json">
        <p>è«‹é¸æ“‡ç¬¦åˆä»¥ä¸‹ **Swagger çµæ§‹** çš„ JSON æª”æ¡ˆã€‚</p>
    </div>

    <div class="dialogue-controls">
        <label for="rateSlider">èªé€Ÿ (Rate): <span id="rateValue">1.0</span></label>
        <input type="range" id="rateSlider" min="0.5" max="2.0" value="1.0" step="0.1">
        
        <p>
            <button id="readAllBtn" disabled>â–¶ï¸ ä¸€æ¬¡éé–±è®€æ‰€æœ‰å°è©±</button>
            <button id="stopBtn" disabled>â¹ï¸ åœæ­¢é–±è®€</button>
        </p>
        <p>é»æ“Šä¸‹æ–¹ä»»ä¸€å¥å°è©±ï¼Œå¯å–®ç¨é–±è®€è©²å¥ã€‚</p>
    </div>

    <h2>ğŸ“œ å°è©±å…§å®¹</h2>
    <div id="dialogueContainer">
        <p>è«‹å…ˆä¸Šå‚³ JSON æª”æ¡ˆã€‚</p>
    </div>

    <div id="log">
        <strong>è¨Šæ¯ç´€éŒ„:</strong><br>
    </div>

    <script>
        const synth = window.speechSynthesis;
        const dialogueContainer = document.getElementById('dialogueContainer');
        const fileInput = document.getElementById('fileInput');
        const rateSlider = document.getElementById('rateSlider');
        const rateValueSpan = document.getElementById('rateValue');
        const readAllBtn = document.getElementById('readAllBtn');
        const stopBtn = document.getElementById('stopBtn');
        const logDiv = document.getElementById('log');

        let dialogueData = null;
        let voices = [];
        let currentUtterance = null;
        let dialogueIndex = 0; // ç”¨æ–¼ä¸€æ¬¡éé–±è®€çš„ç´¢å¼•

        // --- èªéŸ³åˆå§‹åŒ– ---
        function populateVoices() {
            voices = synth.getVoices();
            logMessage(`æ‰¾åˆ° ${voices.length} å€‹èªéŸ³ã€‚`);
            // ç”±æ–¼ç€è¦½å™¨è¼‰å…¥èªéŸ³éœ€è¦æ™‚é–“ï¼Œæ‰€ä»¥ç›£è½ onvoiceschanged
        }

        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = populateVoices;
        } else {
            // æŸäº›ç€è¦½å™¨å¯èƒ½ç›´æ¥è¿”å›èªéŸ³åˆ—è¡¨
            populateVoices();
        }

        // --- æ ¸å¿ƒ TTS å‡½æ•¸ ---
        function speak(text, lang, speakerName) {
            // åœæ­¢ç•¶å‰æ­£åœ¨èªªè©±çš„èªéŸ³
            if (currentUtterance) {
                synth.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(text);
            const rate = parseFloat(rateSlider.value);

            // æ ¹æ“šèªè¨€å’Œèªªè©±è€…åç¨±å˜—è©¦å°‹æ‰¾åˆé©çš„è²éŸ³
            let voiceMatch = voices.find(v => v.lang.startsWith(lang));
            
            // å˜—è©¦æ ¹æ“š speakerName é¸æ“‡ç‰¹å®šåç¨±çš„è²éŸ³ (é€™éœ€è¦çŸ¥é“ç³»çµ±è²éŸ³çš„åç¨±ï¼Œå¯èƒ½ä¸é©ç”¨æ‰€æœ‰ç³»çµ±)
            if (!voiceMatch) {
                voiceMatch = voices.find(v => v.name.toLowerCase().includes(speakerName.toLowerCase()) && v.lang.startsWith(lang));
            }
            
            // å¦‚æœæ²’æœ‰åŒ¹é…åˆ°ï¼Œå°±ç”¨ç¬¬ä¸€å€‹åŒ¹é…èªè¨€çš„è²éŸ³
            if (voiceMatch) {
                utterance.voice = voiceMatch;
                logMessage(`ä½¿ç”¨è²éŸ³: ${voiceMatch.name} (${voiceMatch.lang}) çµ¦ ${speakerName}`);
            } else {
                utterance.lang = lang; // è¨­ç½®èªè¨€æ¨™ç±¤ï¼Œè®“ç³»çµ±è‡ªå‹•é¸æ“‡
                logMessage(`æœªæ‰¾åˆ°ç‰¹å®šè²éŸ³ï¼Œä½¿ç”¨é è¨­è²éŸ³å’Œèªè¨€æ¨™ç±¤: ${lang}`);
            }

            utterance.rate = rate;
            currentUtterance = utterance;

            utterance.onend = () => {
                logMessage(`å°è©±çµæŸ: ${text.substring(0, 30)}...`);
                // æ¸…é™¤é«˜äº®é¡¯ç¤º
                document.querySelectorAll('.current-speaking').forEach(el => el.classList.remove('current-speaking'));
                currentUtterance = null;
            };

            utterance.onerror = (event) => {
                logMessage(`TTS éŒ¯èª¤: ${event.error}`, true);
            };

            synth.speak(utterance);
        }

        // --- å–®å¥é–±è®€ ---
        function handleLineClick(event) {
            const lineElement = event.currentTarget;
            const index = parseInt(lineElement.dataset.index);
            const line = dialogueData.dialogue[index];

            // çªå‡ºé¡¯ç¤ºç•¶å‰å¥å­
            document.querySelectorAll('.current-speaking').forEach(el => el.classList.remove('current-speaking'));
            lineElement.classList.add('current-speaking');

            speak(line.text, dialogueData.language_code, line.speaker);
        }

        // --- ä¸€æ¬¡éé–±è®€æ‰€æœ‰å°è©± ---
        function readAllDialogue() {
            if (!dialogueData) return;

            // ç¢ºä¿åœæ­¢ä»»ä½•ç¾æœ‰çš„èªéŸ³
            synth.cancel();
            
            dialogueIndex = 0;
            readNextLine();
        }

        function readNextLine() {
            if (dialogueIndex >= dialogueData.dialogue.length) {
                logMessage('æ‰€æœ‰å°è©±é–±è®€å®Œç•¢ã€‚');
                stopBtn.disabled = true;
                readAllBtn.disabled = false;
                return;
            }

            const line = dialogueData.dialogue[dialogueIndex];
            const rate = parseFloat(rateSlider.value);
            
            // çªå‡ºé¡¯ç¤ºç•¶å‰å¥å­
            document.querySelectorAll('.current-speaking').forEach(el => el.classList.remove('current-speaking'));
            const lineElement = document.querySelector(`.dialogue-line[data-index="${dialogueIndex}"]`);
            if (lineElement) {
                lineElement.classList.add('current-speaking');
                lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }


            const utterance = new SpeechSynthesisUtterance(line.text);
            utterance.rate = rate;
            utterance.lang = dialogueData.language_code; // é è¨­ä½¿ç”¨ JSON æª”æ¡ˆä¸­çš„èªè¨€
            
            // å˜—è©¦æ ¹æ“šèªªè©±è€…åç¨±å°‹æ‰¾è²éŸ³
            let voiceMatch = voices.find(v => 
                v.name.toLowerCase().includes(line.speaker.toLowerCase()) && 
                v.lang.startsWith(dialogueData.language_code)
            );
            
            if (voiceMatch) {
                utterance.voice = voiceMatch;
            } else {
                utterance.lang = dialogueData.language_code; 
            }
            
            currentUtterance = utterance;
            
            utterance.onend = () => {
                dialogueIndex++;
                readNextLine();
            };

            utterance.onerror = (event) => {
                logMessage(`TTS éŒ¯èª¤: ${event.error} (å¥å­ ${dialogueIndex + 1})`, true);
                dialogueIndex++;
                readNextLine();
            };

            synth.speak(utterance);
        }

        // --- åœæ­¢åŠŸèƒ½ ---
        function stopReading() {
            synth.cancel();
            document.querySelectorAll('.current-speaking').forEach(el => el.classList.remove('current-speaking'));
            stopBtn.disabled = true;
            readAllBtn.disabled = false;
            logMessage('é–±è®€å·²åœæ­¢ã€‚');
        }

        // --- JSON è™•ç† ---
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    dialogueData = JSON.parse(e.target.result);
                    renderDialogue(dialogueData);
                    readAllBtn.disabled = false;
                    logMessage('JSON æª”æ¡ˆè¼‰å…¥æˆåŠŸã€‚');
                } catch (err) {
                    dialogueContainer.innerHTML = '<p style="color: red;">JSON æª”æ¡ˆè§£æéŒ¯èª¤ã€‚è«‹ç¢ºä¿æ ¼å¼æ­£ç¢ºã€‚</p>';
                    readAllBtn.disabled = true;
                    logMessage(`JSON è§£æéŒ¯èª¤: ${err.message}`, true);
                }
            };
            reader.readAsText(file);
        });

        // --- æ¸²æŸ“å°è©± ---
        function renderDialogue(data) {
            if (!data.dialogue || !Array.isArray(data.dialogue)) {
                dialogueContainer.innerHTML = '<p style="color: red;">JSON æ ¼å¼ç„¡æ•ˆï¼šç¼ºå°‘ "dialogue" é™£åˆ—ã€‚</p>';
                readAllBtn.disabled = true;
                return;
            }

            dialogueContainer.innerHTML = `<h3>èªè¨€ä»£ç¢¼ (Language Code): ${data.language_code}</h3>`;
            data.dialogue.forEach((line, index) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'dialogue-line';
                lineDiv.dataset.index = index;
                lineDiv.innerHTML = `<span class="speaker">${line.speaker}:</span><span>${line.text}</span>`;
                lineDiv.addEventListener('click', handleLineClick);
                dialogueContainer.appendChild(lineDiv);
            });
            logMessage('å°è©±å…§å®¹å·²é¡¯ç¤ºã€‚');
        }

        // --- äº‹ä»¶ç›£è½ ---
        rateSlider.addEventListener('input', () => {
            rateValueSpan.textContent = rateSlider.value;
            // å¦‚æœæ­£åœ¨èªªè©±ï¼Œç«‹å³æ›´æ–°èªé€Ÿ
            if (currentUtterance && !synth.paused) {
                currentUtterance.rate = parseFloat(rateSlider.value);
            }
        });

        readAllBtn.addEventListener('click', () => {
            readAllDialogue();
            readAllBtn.disabled = true;
            stopBtn.disabled = false;
        });

        stopBtn.addEventListener('click', stopReading);
        
        // ç•¶ç€è¦½å™¨é–‹å§‹/åœæ­¢æ’­æ”¾æ™‚æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        synth.addEventListener('end', () => {
            if (dialogueIndex >= dialogueData.dialogue.length) {
                stopBtn.disabled = true;
                readAllBtn.disabled = false;
            }
        });
        
        synth.addEventListener('start', () => {
            stopBtn.disabled = false;
        });
        
        // --- è¨Šæ¯ç´€éŒ„ ---
        function logMessage(message, isError = false) {
            const time = new Date().toLocaleTimeString('zh-Hant');
            const color = isError ? 'red' : 'green';
            logDiv.innerHTML += `<span style="color:${color};">[${time}] ${message}</span><br>`;
            logDiv.scrollTop = logDiv.scrollHeight; // æ²å‹•åˆ°åº•éƒ¨
        }
    </script>
</body>
</html>